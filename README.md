# 23种设计模式

## 设计模式的类型

 - 创建型
 - 结构型
 - 行为型

## 创建型

创建模式专注于如何实例化对象或相关对象组。

 - 简单工厂模式（Simple Factory）
 - 工厂方法模式（Factory Method）
 - 抽象工厂模式（Abstract Factory）
 - 构建器模式（Builder）
 - 原型模式（Prototype）
 - 单例模式（Singleton）

### 简单工厂模式（Simple Factory）

简单工厂只是为客户端生成一个实例，而不会向客户端公开任何实例化逻辑。  

什么时候使用：

> 当创建一个对象不仅仅是一些分配而且涉及一些逻辑时，将它放在专用工厂中而不是在任何地方重复相同的代码是有意义的。  

### 工厂方法模式（Factory Method）

它提供了一种将实例化逻辑委托给子类的方法。  

什么时候使用：

> 在类中有一些通用处理但在运行时动态决定所需的子类时很有用。换句话说，当客户端不知道它可能需要什么样的子类时。  

### 抽象工厂模式（Abstract Factory）

工厂的工厂; 一个将单个但相关/从属的工厂分组在一起而没有指定其具体类别的工厂。  

什么时候使用：

> 当涉及到不那么简单的，存在相互依赖关系的创建逻辑时使用  

### 建造者模式（Builder）

允许您创建不同风格的对象，同时避免构造函数污染。当一个对象有多种风格时很有用。或者当一个对象创建时涉及很多步骤。  

维基百科：

> 建造者模式是一种创建对象的软件设计模式，其目的是找到伸缩构造器反模式的解决方案。

什么是伸缩构造函数反模式？ 经常见到如下的构造函数


```java 
public class Constructor{
    public Constructor(int size, String str, boolean isFine){
        this.size = size;
        this.str = str;
        this.isFine = isFine;
    }
}
```

按照上述做法，构造函数参数的数量很快就会失控，并且可能难以理解参数的排列。此外，如果希望将来添加更多选项，参数列表将继续增长。这被称为伸缩构造器反模式。  

什么时候使用：

> 当一个对象可能存在几种类型并避免构造函数伸缩时使用。与工厂模式的主要区别在于：当创建是一步过程时，将使用工厂模式，而当创建是多步骤过程时，将使用建造者模式。

### 原型模式（Prototype）

通过克隆现有对象创建对象  

它允许创建现有对象的副本并根据需要进行修改，而不是从头开始创建对象并进行设置。  

什么时候使用：

> 当需要一个与现有对象类似的对象时，或者与克隆相比，创建的成本会更高。

### 单例模式（Singleton）

确保只有特定类的一个对象被创建。  

单例模式实际上被认为是反模式，应该避免过度使用它。它不一定是坏的，可能有一些有效地使用场景，但应谨慎使用，因为它在您的应用程序中引入了一个全局状态，并且在一个地方更改它可能会影响其他地方，并且它可能变得非常难以调试。关于它们的另一个坏处是它使你的代码紧密耦合加上 mock(一种测试方法)单例可能很困难。

## 结构型

结构模式大多关注对象组成，或者换句话说，实体如何相互使用。或者另一种解释是，它们有助于回答“如何构建软件组件？”

- 适配器模式（Adapter）
- 桥接模式（Bridge）
- 组合模式（Composite）
- 装饰模式（Decorator）
- 门面模式（Facade）
- 享元模式（Flyweight）
- 代理模式（Proxy）

### 适配器模式（Adapter）

适配器模式允许您在适配器中包装其他不兼容的对象，使其与另一个类兼容。(翻译，电源适配器，读卡器)

### 桥接模式（Bridge）

桥接模式是关于优先于继承的组合。实现细节从层次结构推送到具有单独层次结构的另一个对象。  

维基百科：

> 桥接模式是软件工程中使用的设计模式，旨在“将抽象与其实现分离，以便两者可以独立变化”

### 组合模式（Composite）

组合模式允许客户以统一的方式处理单个对象。  

### 装饰模式（Decorator）

装饰器模式允许您通过将对象包装在装饰器类的对象中来动态更改对象在运行时的行为。  

### 门面模式（Facade）

门面模式为复杂的子系统提供了简化的界面。  

维基百科：

> 门面是一个为更大的代码体提供简化的接口的对象，例如一个类库。

### 享元模式（Flyweight）

它用于通过尽可能多地与类似对象共享来最小化内存使用或计算开销。  

### 代理模式（Proxy）

使用代理模式，一个类表示另一个类的功能。  

维基百科：

> 代理最一般的形式，是一个充当其他东西的接口的类。代理是一个包装器或代理对象，用来被客户端调用以访问幕后的提供服务的真实对象。使用代理可以简单地转发到真实对象，或者可以提供额外的逻辑。在代理中，可以提供额外的功能，例如当对真实对象的操作是资源密集时进行缓存，或者在调用对象的操作之前检查先决条件。

## 行为型

它关注对象之间的职责分配。它们与结构型模式的不同之处在于它们不仅指定了结构，还概述了它们之间的消息传递/通信模式。或者换句话说，他们协助回答“如何在软件组件中运行行为？”

- 责任链模式（Chain Of Responsibilities）
- 命令行模式（Command）
- 迭代器模式（Iterator）
- 中介者模式（Mediator）
- 备忘录模式（Memento）
- 观察者模式（Observer）
- 访问者模式（Visitor）
- 策略模式（Strategy）
- 状态模式（State）
- 模板方法模式（Template Method）

### 责任链模式（Chain Of Responsibilities）

现实例子：

> 例如，你的帐户设置有三种付款方式（`A`，`B`和`C`）; 每个都有不同的额度。`A`有 100 美元，`B`具有 300 美元和`C`具有 1000 美元，以及支付偏好被选择作为先`A`再`B`然后`C`。你试着购买价值 210 美元的东西。使用责任链，首先`A`会检查帐户是否可以进行购买，如果是，则进行购买并且责任链破裂。如果不能购买，请求将转发到帐户`B`来检查金额，如果能购买，责任链破裂，否则请求将继续转发，直到找到合适的处理程序。在这里`A`，`B`和`C` 是链条的链接，整个现象是责任链。

它有助于构建一系列对象。请求从一端进入并持续从一个对象到另一个对象，直到找到合适的处理程序。

### 命令行模式（Command）

现实例子：

> 一个通用的例子是你在餐厅点餐。您（即`Client`）要求服务员（即`Invoker`）上一些食物（即`Command`），服务员只是将请求转发给拥有烹饪什么和怎么烹饪的知识的主厨（即`Receiver`）。另一个例子是你（即`Client`）使用遥控器（`Invoker`）打开（即`Command`）电视（即`Receiver`）

允许将操作封装在对象中。这种模式背后的关键思想是提供将客户端与接收器分离的方法。

### 迭代器模式（Iterator）

现实例子：

> 老式收音机将是迭代器的一个很好的例子，用户可以从某个频道开始，然后使用下一个或上一个按钮来浏览相应的频道。或者以 MP3 播放器或电视机为例，您可以按下下一个和上一个按钮来浏览连续的频道，换句话说，它们都提供了一个界面来迭代各自的频道，歌曲或电台。

它提供了一种访问对象元素而不暴露底层表示的方法。  

维基百科：

> 在面向对象的编程中，迭代器模式是一种用于遍历容器并访问容器的元素的设计模式。迭代器模式将算法与容器分离; 在某些情况下，算法必然是特定于容器的，因此不能解耦。

### 中介者模式（Mediator）

现实例子：

> 一个典型的例子就是当你在手机上与某人交谈时，有一个网络提供商坐在你和他们之间，你的对话通过它而不是直接发送。在这种情况下，网络提供商是中介。

Mediator 模式添加第三方对象（称为中介者）来控制两个对象（称为同事）之间的交互。它有助于减少彼此通信的类之间的耦合。因为现在他们不需要了解彼此的实现。

### 备忘录模式（Memento）

备忘录模式是关于获取和存储对象的当前状态，以一种能够用平滑方式恢复的方式。  

维基百科：

> 备忘录模式是一种软件设计模式，它提供将对象恢复到其先前状态的能力（通过回滚撤消）。

当需要提供某种撤消功能时通常很有用。

### 观察者模式（Observer）

现实例子：

> 一个很好的例子是求职者，他们订阅了一些职位发布网站，只要有匹配的工作机会，他们就会得到通知。

定义对象之间的依赖关系，以便每当对象更改其状态时，都会通知其所有依赖项。

维基百科：

> 观察者模式是一种软件设计模式，其中一个称为主体的对象维护其依赖者列表，称为观察者，并在有任何状态变化时自动通知它们，常通过调用它们的某个方法。

