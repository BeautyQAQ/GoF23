# 23种设计模式

## 设计模式的类型

 - 创建型
 - 结构型
 - 行为型

## 创建型

 - 简单工厂模式（Simple Factory）
 - 工厂方法模式（Factory Method）
 - 抽象工厂模式（Abstract Factory）
 - 构建器模式（Builder）
 - 原型模式（Prototype）
 - 单例模式（Singleton）

### 简单工厂模式（Simple Factory）

简单工厂只是为客户端生成一个实例，而不会向客户端公开任何实例化逻辑。  

什么时候使用：

> 当创建一个对象不仅仅是一些分配而且涉及一些逻辑时，将它放在专用工厂中而不是在任何地方重复相同的代码是有意义的。  

### 工厂方法模式（Factory Method）

它提供了一种将实例化逻辑委托给子类的方法。  

什么时候使用：

> 在类中有一些通用处理但在运行时动态决定所需的子类时很有用。换句话说，当客户端不知道它可能需要什么样的子类时。  

### 抽象工厂模式（Abstract Factory）

工厂的工厂; 一个将单个但相关/从属的工厂分组在一起而没有指定其具体类别的工厂。  

什么时候使用：

> 当涉及到不那么简单的，存在相互依赖关系的创建逻辑时使用  

### 建造者模式（Builder）

允许您创建不同风格的对象，同时避免构造函数污染。当一个对象有多种风格时很有用。或者当一个对象创建时涉及很多步骤。  

维基百科：

> 建造者模式是一种创建对象的软件设计模式，其目的是找到伸缩构造器反模式的解决方案。

什么是伸缩构造函数反模式？ 经常见到如下的构造函数


```java
public Constructor(int size, String str, boolean isFine){
    this.size = size;
    this.str = str;
    this.isFine = isFine;
}
```

按照上述做法，构造函数参数的数量很快就会失控，并且可能难以理解参数的排列。此外，如果希望将来添加更多选项，参数列表将继续增长。这被称为伸缩构造器反模式。  

什么时候使用：

> 当一个对象可能存在几种类型并避免构造函数伸缩时使用。与工厂模式的主要区别在于：当创建是一步过程时，将使用工厂模式，而当创建是多步骤过程时，将使用建造者模式。

### 原型模式（Prototype）

通过克隆现有对象创建对象  

它允许创建现有对象的副本并根据需要进行修改，而不是从头开始创建对象并进行设置。  

什么时候使用：

> 当需要一个与现有对象类似的对象时，或者与克隆相比，创建的成本会更高。

### 单例模式（Singleton）

确保只有特定类的一个对象被创建。  

单例模式实际上被认为是反模式，应该避免过度使用它。它不一定是坏的，可能有一些有效的使用场景，但应谨慎使用，因为它在您的应用程序中引入了一个全局状态，并且在一个地方更改它可能会影响其他地方，并且它可能变得非常难以调试。关于它们的另一个坏处是它使你的代码紧密耦合加上 mock(一种测试方法)单例可能很困难。

## 结构型

- 适配器模式（Adapter）
- 桥接模式（Bridge）
- 组合模式（Composite）
- 装饰模式（Decorator）
- 门面模式（Facade）
- 享元模式（Flyweight）
- 代理模式（Proxy）

### 适配器模式（Adapter）

适配器模式允许您在适配器中包装其他不兼容的对象，使其与另一个类兼容。(翻译，电源适配器，读卡器)

