# 23种设计模式

## 设计模式的类型

 - 创建型
 - 结构型
 - 行为型

## 创建型

 - 简单工厂模式（Simple Factory）
 - 工厂方法模式（Factory Method）
 - 抽象工厂模式（Abstract Factory）
 - 构建器模式（Builder）
 - 原型模式（Prototype）
 - 单例模式（Singleton）

### 简单工厂模式（Simple Factory）

简单工厂只是为客户端生成一个实例，而不会向客户端公开任何实例化逻辑。  

什么时候使用：

> 当创建一个对象不仅仅是一些分配而且涉及一些逻辑时，将它放在专用工厂中而不是在任何地方重复相同的代码是有意义的。  

### 工厂方法模式（Factory Method）

它提供了一种将实例化逻辑委托给子类的方法。  

什么时候使用：

> 在类中有一些通用处理但在运行时动态决定所需的子类时很有用。换句话说，当客户端不知道它可能需要什么样的子类时。  

### 抽象工厂模式（Abstract Factory）

工厂的工厂; 一个将单个但相关/从属的工厂分组在一起而没有指定其具体类别的工厂。  

什么时候使用：

> 当涉及到不那么简单的，存在相互依赖关系的创建逻辑时使用  

### 建造者模式（Builder）

允许您创建不同风格的对象，同时避免构造函数污染。当一个对象有多种风格时很有用。或者当一个对象创建时涉及很多步骤。  

维基百科：

> 建造者模式是一种创建对象的软件设计模式，其目的是找到伸缩构造器反模式的解决方案。

什么是伸缩构造函数反模式？ 经常见到如下的构造函数


```java 
public class Constructor{
    public Constructor(int size, String str, boolean isFine){
        this.size = size;
        this.str = str;
        this.isFine = isFine;
    }
}
```

按照上述做法，构造函数参数的数量很快就会失控，并且可能难以理解参数的排列。此外，如果希望将来添加更多选项，参数列表将继续增长。这被称为伸缩构造器反模式。  

什么时候使用：

> 当一个对象可能存在几种类型并避免构造函数伸缩时使用。与工厂模式的主要区别在于：当创建是一步过程时，将使用工厂模式，而当创建是多步骤过程时，将使用建造者模式。

### 原型模式（Prototype）

通过克隆现有对象创建对象  

它允许创建现有对象的副本并根据需要进行修改，而不是从头开始创建对象并进行设置。  

什么时候使用：

> 当需要一个与现有对象类似的对象时，或者与克隆相比，创建的成本会更高。

### 单例模式（Singleton）

确保只有特定类的一个对象被创建。  

单例模式实际上被认为是反模式，应该避免过度使用它。它不一定是坏的，可能有一些有效地使用场景，但应谨慎使用，因为它在您的应用程序中引入了一个全局状态，并且在一个地方更改它可能会影响其他地方，并且它可能变得非常难以调试。关于它们的另一个坏处是它使你的代码紧密耦合加上 mock(一种测试方法)单例可能很困难。

## 结构型

- 适配器模式（Adapter）
- 桥接模式（Bridge）
- 组合模式（Composite）
- 装饰模式（Decorator）
- 门面模式（Facade）
- 享元模式（Flyweight）
- 代理模式（Proxy）

### 适配器模式（Adapter）

适配器模式允许您在适配器中包装其他不兼容的对象，使其与另一个类兼容。(翻译，电源适配器，读卡器)

### 桥接模式（Bridge）

桥接模式是关于优先于继承的组合。实现细节从层次结构推送到具有单独层次结构的另一个对象。  

维基百科：

> 桥接模式是软件工程中使用的设计模式，旨在“将抽象与其实现分离，以便两者可以独立变化”

### 组合模式（Composite）

组合模式允许客户以统一的方式处理单个对象。  

### 装饰模式（Decorator）

装饰器模式允许您通过将对象包装在装饰器类的对象中来动态更改对象在运行时的行为。  

### 门面模式（Facade）

门面模式为复杂的子系统提供了简化的界面。  

维基百科：

> 门面是一个为更大的代码体提供简化的接口的对象，例如一个类库。

### 享元模式（Flyweight）

它用于通过尽可能多地与类似对象共享来最小化内存使用或计算开销。  

